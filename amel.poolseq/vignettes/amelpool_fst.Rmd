---
title: "amelpool_fst"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{amelpool_fst}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(amel.poolseq)
library(ggplot2)
library(dplyr)
library(Imap)
library(reshape2)
library(utils)
```

# Vignette for FST figures

## Define Variables
### From Raw
```{r eval=FALSE}
df <- amel_colnames(pop2names, popool2_fst)

samp_pop <- function(popnames)
  pop2_samp <- data.frame(t(combn(popnames[,1],2)))
  samp_name <- paste(pop2_samp$X1, pop2_samp$X2, sep='.')
  pop2_pop <- data.frame(t(combn(popnames[,2],2)))
  pop_name <- paste(pop2_pop$X1, pop2_pop$X2, sep='')
  amel_fst_df <- data.frame(cbind(samp_name, pop_name))
}

df_stats <- samp_pop(popnames)
````

### From Cluster
```
df <- read.table("all2.fst", header=T)
rm_chars <- function(x){
  as.numeric(gsub('.*_', '', x))
}
df <- df %>% mutate(across(6:ncol(df), rm_chars))

df_stats <- read.table("comp", header=F)
df_stats <- df_stats[,c(2,1)]
```

## Avg. FST per population
mean.n0 excludes zeroes.

```{r}
mean <- colMeans(df[6:ncol(df)])
mean.n0 <- apply(df[6:ncol(df)],2,function(x) mean(x[x>0]))
df_means <- cbind(mean, mean.n0, df_stats)
colnames(df_means) <- c("FST", "FST_n0", "stock", "comp")
rownames(df_means) <- NULL
```

## Aggregate avg. FST by management

```{r}
df_means <- subset(df_means, select=-c(1))
df_means2 <- df_means[order(df_means$FST_n0),]
df_agman <- df_means2 %>% group_by(comp) %>%
  summarize(FST=mean(FST_n0), sd=sd(FST_n0))
```

### Figure
```{r echo=FALSE}
ampop_avfst <- ggplot(df_means2, aes(x=comp, y=FST_n0, color=comp)) + geom_boxplot() + theme(legend.position="none",
        axis.title.x=element_text(color="black", size=15),
        axis.title.y=element_text(color="black", size=15)) +
  ylab("Average FST") + xlab("Management") + 
  ggtitle("Average FST by Comparison") + theme(plot.title=element_text(hjust=0.5))
ampop_avfst
```

### AOV
```{r}
df_aov <- aov(df_means2$FST_n0~df_means2$comp)
summary(df_aov)
df_tukey <- TukeyHSD(df_aov)
plot(df_tukey, las=1)
```

## Fst heatmap by stock
```{r}

df_hm <- df_means %>% mutate(
  Field1 = gsub('[.].*','', df_means$stock), 
  Field2 = gsub('.*[.]','', df_means$stock)
  ) %>% select(!(stock))

##note: code to reorder columns by name (alphabetical)

ggplot(df_hm, aes(Field1, Field2, fill=FST_n0)) + geom_tile() +
  geom_text(aes(label=sprintf("%.3f", FST_n0)), color="white", size=4) +
  labs(x=NULL, y=NULL) +
  coord_fixed() + theme_bw()
```

## Manhattan plot
The first line of code removes unclassified sections of the honey bee genome for easier plotting.

```{r}
ampop_mhdf <- df[-grep("NW_", df$RefContig),]

ampop_mhdf <- ampop_mhdf %>%
  group_by(RefContig) %>%
  summarize(chr_len=max(WindowPos)) %>%
  mutate(tot=cumsum(chr_len)-chr_len) %>%
  select(-chr_len) %>%
  left_join(ampop_mhdf, ., by=c("RefContig"="RefContig")) %>%
  arrange(RefContig, WindowPos) %>%
  mutate(BPcum=WindowPos+tot)

axisdf = ampop_mhdf %>% group_by(RefContig) %>% summarize(center=( max(BPcum) + min(BPcum) ) / 2 )
```
Now that the dataframe has been assembled, the Manhattan plot can be constructed.

```{r}
ampop_manplot <- ggplot(ampop_mhdf, aes(x=BPcum, y=ampop_mhdf[,7])) +
  geom_point( aes(color=as.factor(RefContig)), alpha=0.8, size=1.3) +
  scale_color_manual(values = rep(c("grey", "skyblue"), 70 )) +
  scale_x_continuous( label = axisdf$RefContig, breaks= axisdf$center ) +
  scale_y_continuous() +
  theme_bw() +
  theme( 
    legend.position="none",
    panel.border = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank()
  )

ampop_manplot + facet_wrap(~RefContig, scales="free")
```

## FST by Geographic Distance
### https://eurekastatistics.com/calculating-a-distance-matrix-for-geographic-points-using-r/

I looked to see if there was a relationship between FST and geographic distance. I relied heavily on eurekastatistics functions.

```{r}
ReplaceLowerOrUpperTriangle <- function(m, triangle.to.replace){
  if (nrow(m) !=ncol(m)) stop("Supplied matrix must be square.")
  if (tolower(triangle.to.replace)=="lower") tri <- lower.tri(m)
  else if (tolower(triangle.to.replace)=="upper") tri <- upper.tri(m)
  else stop("triangle.to.replace must be set to 'lower' or 'upper'.")
  m[tri] <- t(m)[tri]
  return(m)
}

GeoDistanceInMetersMatrix <- function(df.geopoints) {
  GeoDistanceInMeters <- function(g1, g2) {
    DistM <- function(g1, g2) {
      require("Imap")
      return(ifelse(g1$index > g2$index, 0, gdist(lat.1=g1$lat, lon.1=g1$lon, lat.2=g2$lat, lon.2=g2$lon, units="m")))
    }
    return(mapply(DistM, g1, g2))
  }
  n.geopoints <- nrow(df.geopoints)
  df.geopoints$index <- 1:n.geopoints
  list.geopoints <- by(df.geopoints[,c("index", "lat", "lon")], 1:n.geopoints, function(x){return(list(x))})
  mat.distances <- ReplaceLowerOrUpperTriangle(outer(list.geopoints, list.geopoints, GeoDistanceInMeters), "lower")
  
  rownames(mat.distances) <- df.geopoints$name
  colnames(mat.distances) <- df.geopoints$name
  
  return(mat.distances)
  
}
```

Sorry, but I will not be posting the actual coordinates of the colonies on a public GitHub...

```{r}
col.loc <- read.csv("pa_coords", sep="\t", header=T)
distance.m <- GeoDistanceInMetersMatrix(col.loc)
colnames(distance.m) <- rbind(col.loc$index)
row.names(distance.m) <- cbind(col.loc$index)
y <- melt(distance.m)

y$value <- replace(y$value, which(y$Var1==y$Var2),NA) 
z <- na.omit(y)

z$file<- paste(z$Var1,z$Var2,sep='.')
a <- subset(z, select=-c(1,2))
b <- merge(a, temp, by="file")
```

Read in Pennsylvania FST.

```{r}
pa2_short <- read.csv("pa2_short.fst", header=T)
df <- amel_colnames(pa2names, pa2_short)

mean <- colMeans(df) #calculate column means
mean.n0 <- apply(df,2,function(x) mean(x[x>0]))
temp <- cbind(mean, mean.n0)
colnames(temp) <- c("FST", "FST_n0")
temp <- subset(temp, select=-c(1))
temp$file <- colnames(temp)
```

Melt dataframe to make chart.

```{r eval=FALSE}
df4$Comb <- paste(df4$RefContig, df4$WindowPos)
samp_names <- unique(df4$Field1)
df5 <- melt(df, id.vars="Comb", measure.vars=dput(as.character(samp_names)))
```
