---
title: "amelpool_gendiv"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{amelpool_gendiv}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(amel.poolseq)
library(dplyr)
library(tidyr)
library(ggplot2)
```

# amelpool_gendiv
## Construct Table
```{r}
df <- hbpop_snpdf(GenDiv, popnames)
```

## Avg. NS by sample
```{r}
table.means <- aggregate(df$NS~df$Field2, df, mean)
table.sd <- aggregate(df$NS~df$Field2, df, sd)
table.ns.sd <- cbind(table.means, table.sd)
  table.ns.sd <- subset(table.ns.sd, select=-c(3))
  colnames(table.ns.sd) <- c("sample", "mean_ns", "sd")
  #write.table(table.ns.sd, "stock.ns", sep="\t", col.names=T, row.names=F)

table.means <- aggregate(df$piS~df$Field2, df, mean)
table.sd <- aggregate(df$piS~df$Field2, df, sd)
table.s.sd <- cbind(table.means, table.sd)
  table.s.sd <- subset(table.ns.sd, select=-c(3))
  colnames(table.s.sd) <- c("sample", "mean_piS", "sd")
  #write.table(table.s.sd, "stock.s", sep="\t", col.names=T, row.names=F)
```

## Genome-wide NS by group
```{r echo=FALSE}
ns_agg <- aggregate(df$NS, by=list(df$Field2), function(x) mean(x, na.rm=TRUE))
ggplot(df, aes(x=Field2, y=NS, color=Field2)) + 
  geom_point(cex=1.5, pch=1.0, position = position_jitter(w=0.1, h=0)) +
  geom_point(data=ns_agg, cex=2, pch=19, aes(x=Group.1, y=x), colour="black") +
  theme_classic() + theme(legend.position = "none",
                          axis.title.x = element_text(color="black", size=10),
                          axis.text.y = element_text(color="black", size=10)) +
  ylab("piS") + xlab("Stock") + geom_hline(yintercept=c(0.00530899), lty=3) +
  ggtitle("piS by Stock")
```

## Significance testing
```{r}
aov <- aov(piS~Field2, data=df)
summary(aov)
tuk <- TukeyHSD(aov)
plot(tuk, las=2, col="red", cex.lab=0.5)
```

## Highest % value SNPs
```{r}
n <- 25 #for top 25%
top25 <- df[df$NS > quantile(df$NS,prob=1-n/100),]
#write.table(top25, "top25_NS", sep="\t", col.names=T, row.names=F)
```

## Pull out genes associated with immune function

```{r}
imm_dt <- left_join(imm_genes, df, by=c("GB"="GBold"))
df2 <- left_join(imm_genes, df, by=c("GB"="GB"))
imm_df <- rbind(imm_dt, df2)
#test <- imm_dt[complete.cases(imm_dt$samp),]
```

```{r echo=FALSE}
u <- aggregate(imm_dt$NS, by=list(imm_dt$Field2), function(x) mean(x, na.rm=TRUE))
piS.plot <- ggplot(imm_dt, aes(x=Field2, y=NS, color=Field2)) + 
  geom_point(cex=1.5, pch=1.0, position = position_jitter(w=0.1, h=0)) +
  geom_point(data=u, cex=2, pch=19, aes(x=Group.1, y=x), colour="black") +
  theme_classic() + theme(legend.position = "none",
                          axis.title.x = element_text(color="black", size=10),
                          axis.text.y = element_text(color="black", size=10)) +
  ylab("piS") + xlab("Stock") + geom_hline(yintercept=c(0.00530899), lty=3) +
  ggtitle("piS by Stock")

```

# Significant differences in feral and managed pop genetic diversity
This loop looks at all the gene IDs and does a t-test between each pair of genes between managed and feral, outputting two files called gene.list (the names of all the genes) and gen.pval (p-value of each t-test). It prints (in console) the names of every gene it works on so you can see exactly when it stalls out.

```{r eval=FALSE}
df2 <- df[-grep("Ref", df$Field1),]
uniq.gene.id <- unique(df2$GBold)
gen.pval <- c()
gene.list <- c()
for(i in uniq.gene.id) {
  print(i)
  temp <- df2[which(df2$GBold==i),]
  length1 <- length(temp$Field1[which(temp$Field1=='Feral')])
  length2 <- length(temp$Field1[which(temp$Field1!='Feral')])
  length3 <- length(unique(temp$samp))
  if(length1>1 & length2>1 & length3>3) {
    temp2 <- t.test(temp$NS ~ temp$Field1)
    gen.pval <- c(temp2$p.value, gen.pval)
    gene.list <- c(i, gene.list)
  }
}

all.pval.ns.gene <- data.frame(cbind(gene.list, as.numeric(as.character(gen.pval))))
colnames(all.pval.ns.gene) <- c("gene", "pval") 
all.pval.ns.gene <- all.pval.ns.gene[!(all.pval.ns.gene$pval=="NaN"),]
```
## *q* value
*q*-value for each gene must also be calculated to correct for the false discovery rate because the previous loop executes many small probability calculations.

```{r}
all.pval.ns.gene$q <- qvalue1(all.pval.ns.gene2$pval)$q 
plot(-log10(all.pval.ns.gene$gene),all.pval.ns.gene$q)
  abline(v=-log10(0.05))
  abline(h=0.05)

pval <- all.pval.ns.gene[(all.pval.ns.gene$q<=0.05),]
#write.table(pval, "gen_div_pval", col.names=T, row.names=F, quote=F)
```

## Pull out genes associated with immune function
```{r}
imm_genes <- data(imm_genes)
imm <- left_join(imm_genes, pval, by=c("GB"="gene"))
imm <- na.omit(imm)
```

### Look at single genes
hbpop_snpsing function allows you to look at differences in genetic diversity between specific genes. This example uses DSCAM.
```{r}
hbpop_snpsing(GenDiv, GB44159)
```

## Genetic Diversity vs. Coverage

Depths output by samtools...include pre-trim variables.

```{r}
depth.samp <- read.csv("dp.csv", fill=T, header=T)
table3 <- merge(depth.samp, table.s.sd, by="Sample.Name")
x<-new.table2[,c('Field2', 'sample')]
names(table3)[1] <- 'sample'
y<-merge(x, table3, by = 'sample')
y<-y[!duplicated(y),]
dep.pi <- y

y <- lm(data=dep.pi, Mean_piS ~ Depth + Field2)
summary(y)
resid <- residuals(y)
dep.pi$resid <- resid
boxplot(dep.pi$resid~dep.pi$Field2)
abline(h=0)

depth.plot <- ggplot(dep.pi, aes(x=Depth, y=Mean_piS)) +
  geom_point(cex=3, pch=19) +
  geom_smooth(method='lm') + 
  ylab("Average piS") + xlab("Sequencing Depth") + ggtitle("Sequencing Depth vs. Average Genome-wide Genetic Diversity")
depth.plot
```


